# Доклад: Многопоточность и конкурентность в JavaScript (Node.js)

<video width="100%" controls>
  <source src="./Доклад.mp4" type="video/mp4">
  Ваш браузер не поддерживает видео тег.
</video>

## Введение
В JavaScript основная логика программы исполняется в одном потоке. Поэтому “классическая” многопоточность (как в C++/Java) в базовой модели отсутствует. При этом язык и платформа дают удобные механизмы конкурентности (асинхронного выполнения), а при необходимости — и реальный параллелизм через воркеры.

## Конкурентность: event loop, асинхронность, Promises
Большинство типовых задач (сетевые запросы, операции ввода-вывода, таймеры) в JavaScript выполняются асинхронно. Программа запускает операцию и не блокируется ожиданием результата: обработчик результата будет выполнен позже, когда событие попадёт в очередь и будет обработано event loop.

Promises и `async/await` являются основной высокоуровневой абстракцией для асинхронного кода. Они упрощают описание “что сделать после завершения операции”, повышают читаемость и позволяют писать последовательную логику без вложенных колбэков. При этом Promises/`async/await` не создают потоки, а лишь организуют продолжение вычислений по завершении асинхронных операций.

## Node.js: почему I/O эффективно без многопоточности JS-кода
Node.js хорошо подходит для I/O-нагрузки за счёт неблокирующей модели выполнения: JavaScript-код продолжает исполняться, пока внешние операции (сеть/файлы) выполняются вне основного потока исполнения JS. Это позволяет обслуживать множество одновременных запросов без необходимости создавать поток на каждый запрос.

Важно: CPU-тяжёлые вычисления, выполненные в основном потоке, блокируют event loop и ухудшают отклик приложения. В таких случаях требуется вынос вычислений из основного потока.

## Реальный параллелизм: Workers
Для параллельного выполнения CPU-задач в JavaScript используются воркеры:
- **Web Workers** в браузере
- **worker_threads** в Node.js

Worker выполняет код в отдельном потоке и общается с основным потоком через сообщения. В Node.js также возможна работа с общей памятью через `SharedArrayBuffer` и синхронизацию с помощью `Atomics`. Это позволяет ускорять вычисления, но требует аккуратности: появляются классические проблемы конкурентного программирования, такие как race condition и deadlock.

## Практические паттерны конкурентности
На практике в JavaScript/Node.js часто применяются следующие подходы:
- **Worker Pool**: очередь вычислительных задач и набор воркеров; первый свободный воркер забирает следующую задачу.
- **Pipeline (конвейер)**: задача последовательно проходит несколько стадий обработки, каждая стадия может быть вынесена в отдельный исполнитель.
- **Fan-out / Fan-in**: разбиение задачи на независимые части, параллельная обработка этих частей и последующее объединение результатов.

## Связь с выполненными лабораторными работами
- В лабораторных по планированию (scheduler) реализовано управление очередями задач: приоритеты, кванты времени, понижение приоритета и периодический “boost” (перемещение задач в очередь высокого приоритета). Это демонстрирует принципы диспетчеризации, аналогичные ОС.
- В лабораторных по конкурентности показаны базовые эффекты многопоточности при общей памяти (race condition, deadlock) и продемонстрированы прикладные паттерны (worker pool, pipeline, fan-in/fan-out).
- В задаче по обработке изображений показано, что двумерные данные хорошо распараллеливаются: изображение можно обрабатывать по строкам/блокам/пикселям в разных воркерах и сравнить производительность с однопоточной версией.

## Вывод
JavaScript предоставляет два уровня работы с “параллельностью”:
1) **Конкурентность** через event loop и асинхронные абстракции (Promises, `async/await`) — эффективна для I/O и большого количества одновременных операций.
2) **Параллелизм** через Workers — необходим для CPU-тяжёлых вычислений и реального ускорения за счёт нескольких потоков.

Выбор подхода зависит от характера нагрузки: I/O-нагрузка эффективно решается асинхронностью, а вычислительная — выносом работы в воркеры и использованием паттернов распределения задач.